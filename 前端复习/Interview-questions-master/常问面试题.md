# 常问面试题

## eval是什么

它的功能是把对应的字符串解析成js代码并运行   
应该避免使用eval   不安全  非常的消耗性能
由JSON字符串转换成JSON对象的时候可以用eval  
var obj = eval('('+ str +')')

##  null和undefined的区别

undefined:表示不存在这个值 如果变量被声明了没有赋值 会是undefined  
null: 变量被定义赋值了但是为空的情况  没有任何属性方法和值     
在验证null时   一定要使用 === ,因为== 无法分别null和undefined.

## 谈谈对json的理解
1.json是javaScript Object Notation 的缩写  即是javascript对象表示法  是一种轻量级的数据交换格式 
2.易于读写和编写
3.同时也易于机器解析和生成 
4.json是存储和交换文本信息的语法类似于XML
5.json采用完全独立于语言的文本格式

它的语言格式类似于c语言家族

## 同步和异步的区别   
 同步:浏览器访问服务器请求 用户看得到页面刷新 重新发送请求  请求完  页面刷新  用户看到新内容  进行下一步操作
 异步:浏览器访问服务器请求 用户正常操作  浏览器后端进行请求 等请求完  页面不刷新  新内容也会出现

## 什么是面向对象和面向过程

面向过程  就是对一个问题提出解决思路  然后一步一步的列出函数解决  依次调用。
面向对象就是将构成问题分解成各个对象  建立对象的目的不是为了完成一个步骤  而是为了描述某个食物在整个解决问题的步骤中的行为。面向对象是以功能来划分问题不是步骤。

## 怎么解决跨域问题 

jsonp 
iframe
window.name
window.postMessage
服务器上设置代理页面

## ajax的优缺点
优点：通过异步模式  提升了用户体验  优化了浏览器和服务器之间的传输  减少了数据带宽占用    
Ajax在客户端运行  承担了一部分本来由服务器承担的工作 减少了大用户量下的服务器负载  Ajax可以实现动态不刷新(局部刷新)   

缺点:安全问题   ajax暴露了与服务器交互的细节  对搜索引擎的支持比较弱  不容易调试

## base64的原理以及优缺点


##  为什么要初始化css样式

因为浏览器的兼容性问题  不同的浏览器  内核不同  比如有四大浏览器  分别是  Chrome (Blink) Safari(Weblit) FireFox(Gecko) Opera(Blink引擎) 
内核不同  所以才造成解析不一样

## link和@import的区别

1.link是html的方式,@import是css提供的.
2.页面被加载时  link会同时被加载   而@import引用的css会等到页面加载结束后加载。
3.link最大限度支持并行下载
4.@import过多嵌套导致串行下载
5.link可以通过rel = “alternate stylesheet”指定候选样式
6.总体来说  link优于@import

## reset和normilize的区别

1. 两者都是重置浏览器样式 对浏览器默认样式进行了统一
2. reset 几乎对所有的样式都进行了重置  而normilize只是修改了部分样式 保持尽可能的一致
3. normilize修复了常见的桌面端和移动端浏览器的bug  :包含了HTML5的显示设置  预格式化文字的font-size问题   在IE9中SVG的溢出   许多出现在各浏览器和操作系统的与表单相关的bug
4. 前者含有大段的继承链
5. 后者模块化  文档较前者来说比较丰富


## 网站性能优化

1.资源文件css js图片压缩合并
2.减少页面dom操作   操作多的话可以考虑使用虚拟dom  
3.减少http请求  
4.使用cdn加速
5.减小cookies的大小
6.减少重绘与重排的次数

## 使一个div盒子垂直居中的方法

1.绝对定位  

使用
top:50%; (相对于父亲盒子大小)
left:50%;
transform:translate(-50%,-50%);(相对于自身大小)

缺点: 
IE8不支持   
属性需要写浏览器厂商的前缀  
可能干扰其它transform效果


2.flex布局(在父级盒子上面加上3句话,就可以实现水平垂直居中)
将父亲盒子设置成  
display:flex;
justify-content:center;  
aligin-items:center;

3.盒子有固定的宽和高  
用margin 负间距  
1.必须知道该div的高度和宽度
2.然后设置位置为绝对定位   
3.top:50%; left: 50%;  margin-top:-9px;  margin-left: -200px;
(margin 的负值是相对于自身的负值)。


4.margin:auto  实现绝对定位元素的居中

1.上下左右均0位置定位
2.margin : auto;

## sessionStorage,localStorage  cookie  Web Storage之间的区别  

1.
cookie存储比较小   4kb
webStorage:   5mb  
2.数据存储有效期限：
cookie:根据自己设置生命周期
sessionStorage:关闭窗口就不在

localStorage：永久有效除非JS删除或者浏览器删除
作用域:cookie和localStorage是在同一个窗口,同一个浏览器共享的
sessionStorage只在同一个标签页共享

## ajax轮询

轮询是一种CPU决策如何提供周边设备服务的方式,又称为“程控输出入”(Programmed I/O问).
轮询法的概念是  由CPU定时发出询  依序询问每一个周边设备是否需要其服务   有即予以服务   服务结束后再问下一个周边  接着不断周而复始。

在WEB上来说就是客户端一直向服务端发起请求，服务端返回数据，不论返回什么都会再次向服务端发送请求。

　　那么这样的一种技术优点显而易见，实现容易；但是缺点也非常明显，效率很低。而且当访问量大时，服务器的压力是非常大的。


```javascript

<script>
 2     setInterval("test()",500);
 3     function test() {
 4         $.ajax({
 5             url: '/new_window_url/',
 6             async:true,
 7             type: 'get',
 8             success: function (data) {
 9                 var new_url =  $('#new_iframe').attr('src');
10                 if (new_url !== data){
11                     $('#new_iframe').attr('src', data);
12                 }
13             }
14         })
15     }
16 </script>

```

setInterval按照固定的周期（单位是毫秒）去执行一个函数或者计算表达式。在Ajax请求里有一个参数非常重要，async为True时代表了是异步请求，这样不会锁死浏览器，但是为False时代表了同步请求会锁住浏览器。

运用场景:
当在操作浏览器时，我点击A页面的一个按钮，要弹出一个空白的B页面。我在A上进行特定操作时，B页面要跳转到A页面的选中的数据的URL所对应的页面。


## flex布局(弹性盒子布局)

优势:
1.独立的高度控制与对齐  
2.独立的元素顺序  
3.指定元素之间的关系  
4.灵活的尺寸与对齐方式  


##  函数节流

背景:
在日常的开发过程中   会有这样的场景   事件被频繁的触发   比如说我们在输入的时候 监控keypress事件
在页面滚动的时候  监控页面的滚动事件   比如监控页面的resize事件  拉动窗口改变大小的时候    resize事件被频繁的执行  


事件处理函数简单的还可以  但是如果是复杂的dom操作  就可能导致整个UI卡顿  设置浏览器崩溃  可以通过去抖来处理

去抖:
函数执行几秒后  才会执行   如果函数在n秒内被调用的话  则函数不执行  重新计算执行时间

函数节流：
函数预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期
需要注意的一点：函数的节流和函数的去抖都是通过减少实际逻辑处理过程的执行来提高事件处理函数运行性能的手段，并没有实质上减少事件的触发次数。
## mvvm   mvc  

## 如何检测内存泄漏

定义:不在使用的内存  没有及时释放  就叫做内存泄漏
有的语言必须是手动释放内存  比如说 c语言 
但是大多数的内存机制  都有垃圾回收机制   就是不再使用的内存空间 一段时间会自动释放
 
1.引用计数

检测:  
1.浏览器  
Chrome浏览器查看内存占用   
2.命令行  
用node的一个命令行
用process.memoryUsage方法 
process.memoryUsage返回一个对象  包含了Node进程的内存占用信息 。 该对象包含了四个字段   单位是字节    
含义如下：

rss（resident set size）：所有内存占用，包括指令区和堆栈。
heapTotal："堆"占用的内存，包括用到的和没用到的。
heapUsed：用到的堆的部分。
external： V8 引擎内部的 C++ 对象占用的内存。

判断内存泄漏  以heapUsed字段为准

3.WeakMap

最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。

ES6推出了两种 新的数据结构:
WeakSet和WeakMap   它们对于值得引用都是不计入垃圾回收机制的  
表示弱引用。

DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失

基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。。

## css Hack 

不通过的浏览器 因为有不同的内核  所以解析出来的页面效果也不一样  相同的css代码 在不同的浏览器上有不同的  效果  所以 需要我们处理浏览器的兼容性  说白了  css Hack就是为了兼容浏览器.

## 使用table布局对seo的影响

1.table布局后 结构比较复杂  再来修改很难修改  带来很大的不便利    表格通常是用来显示数据的
2.div更利于优化   
3.table布局 表格嵌套复杂  搜索引擎不好搜索   蜘蛛不好抓取   而div+css  代码结构简单  搜索引擎更容易捕捉 
4.表格在布局时  里面的数据会被嵌套在 任何一个表格中 每次加载页面 都会重新加载数据 

## 为什么使用多个域名来存储网站资源会更加有效 

## ajax的全局函数

1.ajaxComplete();  请求完成时调用
2..ajaxError()  ajax出错时  注册一个回调函数
3..ajaxSend()  在 ajax请求之前调用
4..ajaxStart()   请求开始时执行
5.ajaxStop()  完成时 执行
6.ajaxSuccess()  请求成功时用

## 如何写一个loading效果 

在Ajax发送之前 写一个回调函数  beforeSend:function(){}


## 如何判断一个数组的类型

1.从原型入手
用Array.prototype.isPrototypeOf(obj)

Array.prototype.isPrototypeOf([])
//利用isPrototypeOf ()方法  判定Array是不是在obj的原型链中   如果是  则返回true

2.从构造函数方向
obj  instanceof Array
typeof  和  instanceof   两者都可以用来判断变量 前者返回基本数据类型  后者返回复杂数据类型
instanceof只会返回一个布尔值

## 什么是web  worker?  为什么要使用它?

  web worker用于异步执行 javascript文件 提高浏览器的敏捷度

## vue

## js框架与库的区别

js库的代表有: jquery  zepto  art-template

1. 库的概念是把一些常用的函数进行了封装 我们在使用的时候  直接调用这些方法 
2. 使用的时候  只需要引入这个库 就可以 
3. 在实现的时候  写自己的代码  当需要一些方法时  可以直接调用这些方法

框架的代表:bootstrap mui vue angular react

1. 框架是进行了一个完整的架构  完整的代码  当我们使用的时候 直接将符合适用于当前项目的合适的代码  拷贝过去  只需要将样式适当改下一下就可以  框架实现了部分的基本功能
2. 当我们还未满足需求时  就自己再添加方法 方法的逻辑就是自己实现的
3. 框架相对来说代码量更大   框架中 也可以再引用库  
4. 使用框架 可以增加开发的效率 

## 函数节流

概念：函数节流是通过一个定时器，阻断连续重复的函数调用,从而一定程度上优化性能。

函数节流指的是在规定时间内重复触发不重复执行

函数节流的思想是  设置一个定时器  在指定时间间隔内运行代码时  清除上一次的定时器  并设置另一个定时器 知道函数请求停止 并超过时间间隔才会执行

函数节流主要是锁的思想  当上一个执行完毕才解锁  

## 函数节流的原理

某些代码不可以在没有间断的情况连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。

isFinished = true  
```javascript
  methods: {
        start() {
          // 如果有定时器在跑， 直接返回
          if (this.timeId) return
          this.timeId = setInterval(() => {
            // 开启一个定时器，每次让msg的第一个字符串放到最后一个
            let first = this.msg.charAt(0)
            this.msg = this.msg.slice(1) + first
          }, 300)
        },
        stop() {
          clearInterval(this.timeId)
          // 把timeId的值清空
          this.timeId = ''
        }
      }
```

## 函数防抖 

函数防抖指的是规定时间内重复触发只执行最后一次  以防止频繁触发带来的抖动  

如输入框搜索时，如果每当输入框有一个字变化就搜索，一是对频繁请求对服务器压力大，二是前端也会频繁的闪现搜索的结果，用户体验不好。所以一般都会有个延时，等用户输入延迟一段时间后确定不再输入再进行搜索。


## 节流与防抖的对比

节流是先执行一次，然后过规定时间之后才能再执行。防抖是过了规定时间之后没再触发，最后执行一次。
节流是锁的思想，防抖是清除定时器的思想。
注意最后返回结果都是函数，而且要注意函数中的this指向是返回函数的this。

## 时间格式化

new Date().toLocaleString()