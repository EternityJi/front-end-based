# 调用堆栈

 js内存空间分为站,堆，池(一般也会归类为栈中).  

 其中,栈存放变量,堆存放复杂常量,所以也叫常量池。

.基本类型:-->栈 内存(不包含闭包中的变量)
.引用类型:-->堆 内存

今日补充一个知识点，就是闭包中的变量并不保存中栈内存中，而是保存在堆内存中，这也就解释了函数之后之后为什么闭包还能引用到函数内的变量。

```javascript
function A() {
  let a = 1
  function B() {
      console.log(a)
  }
  return B
}
```

闭包的简单定义是：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。  

函数 A 弹出调用栈后，函数 A 中的变量这时候是存储在堆上的，所以函数B依旧能引用到函数A中的变量。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。

## 内存回收

JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。

1.局部变量和全局变量的销毁  
  局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。  
  全局变量:全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。

2.以Google的V8引擎为例，V8引擎中所有的JS对象都是通过堆来进行内存分配的 

  初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。
继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。  

3.V8引擎对堆内存中的JS对象进行分代管理  
  新生代：存活周期较短的JS对象，如临时变量、字符串等。  

  老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。

## 垃圾回收算法

 对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。

## 垃圾回收的两种策略

   1.引用计数(不常用) 

     引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需要了。  
     引用计数有一个致命的问题，那就是循环引用  
     如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。

```javascript
  function cycle() {
    var o1 = {};
    var o2 = {};
    o1.a = o2;
    o2.a = o1; 

    return "cycle reference!"
}


cycle();
```

```javascript

var div = document.createElement("div");
div.onclick = function() {
    console.log("click");
};

```

上面就是一个循环引用

2.标记清除(现代浏览器常用)  

标记清除算法将“不再使用的对象”定义为“无法到达的对象”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。

这个算法假定设置一个叫做根(root)的对象(在javascript里.根是全局对象)。定期的,垃圾回收器将从根开始,
找所有从根开始引用食物对象,然后找这些对象引用的对象....从根开始,垃圾回收器将找到所有可以获得的对象和所有不能得到的对象。  

所以现在对于主流浏览器来说，只需要切断需要回收的对象与根部的联系  
最常见的内存泄露一般都与DOM元素绑定有关：


上面代码中，div元素已经从DOM树中清除，但是该div元素还绑定在email对象中，所以如果email对象存在，那么该div元素就会一直保存在内存中。

## 引用计数

引用计数的说明:  

//变量obj引用了这个对象({})  
var obj = {}  计数:1  

//变量o引用了这个对象({})
var o = obj   计数:2

//手动释放变量占用的内存
obj = null    计数:1
0 = null      计数:0

说明:将变量obj 和 o 分别设置为null   就没有任何方式获取到我们创建的对象({})了
那么,这个对象({})占用的内存  将来就会被垃圾回收机制回收

## 标记清除

常用垃圾回收算法叫做**标记清除 （Mark-and-sweep） **，算法由以下几步组成：

1、垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；

2、所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。

3、所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。

现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。


## 问题

从内存机制 看 null 和undefined 本质区别是什么

给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为null，或者局部变量赋值为null,相当于给这个属性分配了一块空的内存，然后值为null， JS会回收全局变量为null的对象。

给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在,如果是给对象的属性赋值 为undefined，说明这个值为空值